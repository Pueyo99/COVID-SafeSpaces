Index: app/src/main/java/com/example/covidsafespaces/ServerConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.covidsafespaces;\r\n\r\nimport android.app.AlertDialog;\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Color;\r\nimport android.graphics.Matrix;\r\nimport android.media.ExifInterface;\r\nimport android.os.Looper;\r\nimport android.provider.SyncStateContract;\r\nimport android.util.Base64;\r\nimport android.util.Log;\r\nimport android.view.Gravity;\r\nimport android.view.ViewGroup;\r\nimport android.view.Window;\r\nimport android.view.WindowManager;\r\nimport android.view.textclassifier.ConversationActions;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.ProgressBar;\r\nimport android.widget.TextView;\r\n\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.DataOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URL;\r\n\r\nimport javax.net.ssl.HostnameVerifier;\r\nimport javax.net.ssl.SSLSession;\r\n\r\nimport okhttp3.Call;\r\nimport okhttp3.Callback;\r\nimport okhttp3.MediaType;\r\nimport okhttp3.OkHttpClient;\r\nimport okhttp3.Request;\r\nimport okhttp3.RequestBody;\r\nimport okhttp3.Response;\r\nimport okhttp3.internal.tls.OkHostnameVerifier;\r\n\r\n\r\npublic class ServerConnection {\r\n\r\n    //private final String serverURL = \"http://147.83.50.15:8999/\";\r\n    private final String serverURL = \"https://192.168.1.202:5000/\";\r\n\r\n    public void postImage(final byte[] image, final String filename, final int rotation){\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                OkHttpClient client = new OkHttpClient.Builder().hostnameVerifier(new HostnameVerifier() {\r\n                    @Override\r\n                    public boolean verify(String hostname, SSLSession session) {\r\n                        return true;\r\n                    }\r\n                }).build();\r\n\r\n                JSONObject data = new JSONObject();\r\n                try {\r\n                    data.put(\"image\",Base64.encodeToString(image, Base64.DEFAULT));\r\n                    data.put(\"filename\", filename);\r\n                    data.put(\"rotation\", rotation);\r\n                } catch (JSONException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n                RequestBody body = RequestBody.create(data.toString(),MediaType.parse(\"application/json\"));\r\n                Request request = new Request.Builder().url(serverURL+\"image\").post(body).build();\r\n\r\n                client.newCall(request).enqueue(new Callback() {\r\n                    @Override\r\n                    public void onFailure(@NotNull Call call, @NotNull IOException e) {\r\n                        call.cancel();\r\n                        Log.i(\"prueba\", e.toString());\r\n                        Log.i(\"prueba\", \"Ha fallado la conexión\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {\r\n                        //Log.i(\"prueba\", response.body().string());\r\n                        Log.i(\"prueba\", \"Imagen guardada en el servidor\");\r\n                    }\r\n                });\r\n            }\r\n        }).start();\r\n    }\r\n\r\n    public void get(final String data, final Listener listener){\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                OkHttpClient client = new OkHttpClient.Builder().hostnameVerifier(new HostnameVerifier() {\r\n                    @Override\r\n                    public boolean verify(String hostname, SSLSession session) {\r\n                        return true;\r\n                    }\r\n                }).build();\r\n                Request request = new Request.Builder().url(serverURL+data).get().build();\r\n\r\n                client.newCall(request).enqueue(new Callback() {\r\n                    @Override\r\n                    public void onFailure(@NotNull Call call, @NotNull IOException e) {\r\n                        call.cancel();\r\n                        e.printStackTrace();\r\n                        Log.i(\"prueba\", \"Ha fallado la conexión\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {\r\n                        String data = response.body().string();\r\n                        Log.i(\"prueba\", data);\r\n                        try {\r\n                            listener.receiveMessage(new JSONObject(data));\r\n                        } catch (JSONException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }).start();\r\n    }\r\n\r\n    public void register(final String username, final String password){\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                OkHttpClient client = new OkHttpClient.Builder().hostnameVerifier(new HostnameVerifier() {\r\n                    @Override\r\n                    public boolean verify(String hostname, SSLSession session) {\r\n                        return true;\r\n                    }\r\n                }).build();\r\n\r\n                JSONObject data = new JSONObject();\r\n                try {\r\n                    data.put(\"username\",username);\r\n                    data.put(\"password\", password);\r\n                } catch (JSONException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n                RequestBody body = RequestBody.create(data.toString(),MediaType.parse(\"application/json\"));\r\n                Request request = new Request.Builder().url(serverURL+\"register\").post(body).build();\r\n\r\n                client.newCall(request).enqueue(new Callback() {\r\n                    @Override\r\n                    public void onFailure(@NotNull Call call, @NotNull IOException e) {\r\n                        call.cancel();\r\n                        Log.i(\"prueba\", e.toString());\r\n                        Log.i(\"prueba\", \"Ha fallado la conexión\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {\r\n                        //Log.i(\"prueba\", response.body().string());\r\n                        Log.i(\"prueba\", \"Registro realizado con éxito\");\r\n                    }\r\n                });\r\n            }\r\n        }).start();\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/covidsafespaces/ServerConnection.java	(revision 18c3b924d92e2a093285e0e703d8f9550e99715b)
+++ app/src/main/java/com/example/covidsafespaces/ServerConnection.java	(date 1603964882556)
@@ -50,10 +50,10 @@
 
 public class ServerConnection {
 
-    //private final String serverURL = "http://147.83.50.15:8999/";
-    private final String serverURL = "https://192.168.1.202:5000/";
+    private final String serverURL = "http://147.83.50.15:8999/";
+    //private final String serverURL = "https://192.168.1.202:5000/";
 
-    public void postImage(final byte[] image, final String filename, final int rotation){
+    public void postImage(final byte[] image, final String filename, final int rotation, final Listener listener){
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -86,6 +86,13 @@
 
                     @Override
                     public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
+                        try {
+                            JSONObject data = new JSONObject(response.body().string());
+                            data.put("function", "post");
+                            listener.receiveMessage(data);
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                        }
                         //Log.i("prueba", response.body().string());
                         Log.i("prueba", "Imagen guardada en el servidor");
                     }
@@ -120,7 +127,9 @@
                         String data = response.body().string();
                         Log.i("prueba", data);
                         try {
-                            listener.receiveMessage(new JSONObject(data));
+                            JSONObject object = new JSONObject(data);
+                            object.put("function", "get");
+                            listener.receiveMessage(object);
                         } catch (JSONException e) {
                             e.printStackTrace();
                         }
Index: app/src/main/java/com/example/covidsafespaces/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.covidsafespaces;\r\n\r\nimport data.DBAccess;\r\n\r\nimport android.Manifest;\r\nimport android.annotation.SuppressLint;\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Color;\r\nimport android.graphics.ImageFormat;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Point;\r\nimport android.graphics.RectF;\r\nimport android.graphics.SurfaceTexture;\r\nimport android.hardware.Camera;\r\nimport android.hardware.Sensor;\r\nimport android.hardware.SensorEvent;\r\nimport android.hardware.SensorEventListener;\r\nimport android.hardware.SensorManager;\r\nimport android.hardware.camera2.CameraAccessException;\r\nimport android.hardware.camera2.CameraCaptureSession;\r\nimport android.hardware.camera2.CameraCharacteristics;\r\nimport android.hardware.camera2.CameraDevice;\r\nimport android.hardware.camera2.CameraManager;\r\nimport android.hardware.camera2.CaptureRequest;\r\nimport android.hardware.camera2.CaptureResult;\r\nimport android.hardware.camera2.TotalCaptureResult;\r\nimport android.hardware.camera2.params.StreamConfigurationMap;\r\nimport android.location.Address;\r\nimport android.location.Geocoder;\r\nimport android.location.Location;\r\nimport android.location.LocationManager;\r\nimport android.media.Image;\r\nimport android.media.ImageReader;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\n\r\nimport android.os.Environment;\r\nimport android.os.Handler;\r\nimport android.os.HandlerThread;\r\nimport android.provider.Settings;\r\nimport android.util.Log;\r\nimport android.util.Size;\r\nimport android.util.SparseIntArray;\r\nimport android.view.Gravity;\r\nimport android.view.LayoutInflater;\r\nimport android.view.OrientationEventListener;\r\nimport android.view.Surface;\r\nimport android.view.TextureView;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.view.Window;\r\nimport android.view.WindowManager;\r\nimport android.widget.Button;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.PopupWindow;\r\nimport android.widget.ProgressBar;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.core.content.ContextCompat;\r\n\r\nimport com.google.android.gms.location.FusedLocationProviderClient;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.android.gms.location.LocationSettingsRequest;\r\nimport com.google.android.gms.tasks.OnSuccessListener;\r\n\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.concurrent.Semaphore;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main extends AppCompatActivity implements Listener {\r\n\r\n    private static final int MAX_PREVIEW_WIDTH = 1920;\r\n    private static final int MAX_PREVIEW_HEIGHT = 1080;\r\n    private static final int REQUEST_CAMERA_PERMISSION = 1;\r\n    //private static final int REQUEST_STORAGE_PERMISSION = 2;\r\n    private final int REQUEST_GPS_LOCATION = 3;\r\n    private static final int STATE_PREVIEW = 0;\r\n    private static final int STATE_WAIT_LOCK = 1;\r\n\r\n    /*private static final SparseIntArray ORIENTATIONS = new SparseIntArray();\r\n    static {\r\n        ORIENTATIONS.append(Surface.ROTATION_0, 0);\r\n        ORIENTATIONS.append(Surface.ROTATION_90, 90);\r\n        ORIENTATIONS.append(Surface.ROTATION_180, 180);\r\n        ORIENTATIONS.append(Surface.ROTATION_270, 270);\r\n    }\r\n\r\n     */\r\n\r\n\r\n    /*private File mImageFolder;\r\n    private String mImageFileName;\r\n\r\n     */\r\n\r\n    private int mCaptureState = STATE_PREVIEW;\r\n\r\n    private AlertDialog alertDialog;\r\n    private FusedLocationProviderClient mFusedLocationClient;\r\n    private String countryName;\r\n    private Button captureButton;\r\n    private Button endButton;\r\n    private String mCameraId;\r\n    private AutoFitTextureView mTextureView;\r\n    private int mSensorOrientation;\r\n    private CameraCaptureSession mCaptureSession;\r\n    private CameraCaptureSession mPreviewCaptureSession;\r\n    private CameraCaptureSession.CaptureCallback mPreviewCaptureCallback = new\r\n            CameraCaptureSession.CaptureCallback() {\r\n                private void process(CaptureResult captureResult) {\r\n                    switch (mCaptureState) {\r\n                        case STATE_PREVIEW:\r\n                            //Do nothing\r\n                            break;\r\n                        case STATE_WAIT_LOCK:\r\n                            mCaptureState = STATE_PREVIEW;\r\n                            Integer afState = captureResult.get(CaptureResult.CONTROL_AF_STATE);\r\n                            if (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED || afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED) {\r\n                                startStillCaptureRequest();\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {\r\n                    super.onCaptureCompleted(session, request, result);\r\n                    process(result);\r\n                    mPreviewCaptureSession = session;\r\n                }\r\n            };\r\n    private CameraDevice mCameraDevice;\r\n    private Size mPreviewSize;\r\n    private Size mImageSize;\r\n    private int mDisplayRotation;\r\n    private HandlerThread mBackgroundThread; //To avoid long time tasks running on the UI thread\r\n    private Handler mBackgroundHandler;\r\n    private ImageReader mImageReader;\r\n    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener = new\r\n            ImageReader.OnImageAvailableListener() {\r\n                @Override\r\n                public void onImageAvailable(ImageReader reader) {\r\n                    mBackgroundHandler.post(new ImageSaver(reader.acquireLatestImage()));\r\n                }\r\n            };\r\n\r\n    private class ImageSaver implements Runnable {\r\n        private final Image mImage;\r\n\r\n        public ImageSaver(Image image) {\r\n            mImage = image;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            ByteBuffer byteBuffer = mImage.getPlanes()[0].getBuffer();\r\n            byte[] bytes = new byte[byteBuffer.remaining()];\r\n            byteBuffer.get(bytes);\r\n            new ServerConnection().postImage(bytes, createFileName(), mDisplayRotation);\r\n            mImage.close();\r\n            /*FileOutputStream fileOutputStream = null;\r\n            try {\r\n                fileOutputStream = new FileOutputStream(mImageFileName);\r\n                fileOutputStream.write(bytes);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                mImage.close();\r\n                if(fileOutputStream != null){\r\n                    try {\r\n                        fileOutputStream.close();\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }*/\r\n        }\r\n    }\r\n\r\n    private CaptureRequest.Builder mPreviewRequestBuilder;\r\n    private CaptureRequest mPreviewRequest;\r\n    private Semaphore mCameraOpenCloseLock = new Semaphore(1);\r\n\r\n    private final TextureView.SurfaceTextureListener mSurfaceTextureListener = new TextureView.SurfaceTextureListener() {\r\n        @Override\r\n        public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {\r\n            openCamera(width, height);      //when TextureView is available we open the camera\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {\r\n            configureTransform(width, height);\r\n        }\r\n\r\n        @Override\r\n        public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureUpdated(SurfaceTexture surface) {\r\n\r\n        }\r\n    };\r\n\r\n    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {\r\n        @Override\r\n        public void onOpened(@NonNull CameraDevice camera) {\r\n            mCameraOpenCloseLock.release();\r\n            mCameraDevice = camera;\r\n            createCameraPreviewSession();\r\n        }\r\n\r\n        @Override\r\n        public void onDisconnected(@NonNull CameraDevice camera) {\r\n            mCameraOpenCloseLock.release();\r\n            camera.close();\r\n            mCameraDevice = null;\r\n        }\r\n\r\n        @Override\r\n        public void onError(@NonNull CameraDevice camera, int error) {\r\n            mCameraOpenCloseLock.release();\r\n            camera.close();\r\n            mCameraDevice = null;\r\n            finish();\r\n        }\r\n    };\r\n\r\n    @Override\r\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.main);\r\n\r\n        //createImageFolder();\r\n        addOrientationListener();\r\n        mTextureView = (AutoFitTextureView) findViewById(R.id.texture);\r\n\r\n        captureButton = findViewById(R.id.captureButton);\r\n        captureButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                lockFocus();\r\n                Toast.makeText(getApplicationContext(), \"Image captured\", Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n\r\n        endButton = findViewById(R.id.endButton);\r\n        endButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                setProgressDialog();\r\n                new ServerConnection().get(\"275.0\", Main.this);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    public void getLocation() {\r\n\r\n        /*if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            requestUbicationPermission();\r\n            return;\r\n        }\r\n\r\n         */\r\n\r\n        /*if(!isLocationEnabled()){\r\n            showSettingsAlert();\r\n            return;\r\n        }\r\n\r\n         */\r\n\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            return;\r\n        }\r\n        mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this);\r\n        mFusedLocationClient.getCurrentLocation(LocationRequest.PRIORITY_HIGH_ACCURACY, null).addOnSuccessListener(this, new OnSuccessListener<Location>() {\r\n            @Override\r\n            public void onSuccess(Location location) {\r\n                Log.i(\"prueba\", \"Ha habido exito\");\r\n                if(location != null){\r\n                    getCountryName(location.getLatitude(), location.getLongitude());\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public void showSettingsAlert(){\r\n        AlertDialog.Builder alertDialog = new AlertDialog.Builder(Main.this);\r\n\r\n        // Setting Dialog Title\r\n        alertDialog.setTitle(\"GPS is settings\");\r\n\r\n        // Setting Dialog Message\r\n        alertDialog.setMessage(\"GPS is not enabled. Do you want to go to settings menu?\");\r\n\r\n        // On pressing the Settings button.\r\n        alertDialog.setPositiveButton(\"Settings\", new DialogInterface.OnClickListener() {\r\n            public void onClick(DialogInterface dialog,int which) {\r\n                Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);\r\n                Main.this.startActivity(intent);\r\n            }\r\n        });\r\n\r\n        // On pressing the cancel button\r\n        alertDialog.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                dialog.cancel();\r\n                finish();\r\n            }\r\n        });\r\n\r\n        // Showing Alert Message\r\n        alertDialog.create().show();\r\n    }\r\n\r\n    public boolean isLocationEnabled()\r\n    {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\r\n// This is new method provided in API 28\r\n            LocationManager lm = (LocationManager) Main.this.getSystemService(Context.LOCATION_SERVICE);\r\n            return lm.isLocationEnabled();\r\n        } else {\r\n// This is Deprecated in API 28\r\n            int mode = Settings.Secure.getInt(getContentResolver(), Settings.Secure.LOCATION_MODE,\r\n                    Settings.Secure.LOCATION_MODE_OFF);\r\n            return  (mode != Settings.Secure.LOCATION_MODE_OFF);\r\n\r\n        }\r\n    }\r\n\r\n    public void getCountryName(double latitude, double longitude){\r\n        Log.i(\"prueba\", \"He entrado a pillar el nombre\");\r\n        Geocoder geocoder = new Geocoder(this, Locale.getDefault());\r\n        List<Address> addresses = null;\r\n        try{\r\n            addresses = geocoder.getFromLocation(latitude, longitude, 1);\r\n            Address result;\r\n\r\n            if (addresses != null && !addresses.isEmpty()){\r\n                countryName = addresses.get(0).getCountryCode();\r\n                //countryName = addresses.get(0).getCountryName();\r\n                //Toast.makeText(Main.this, \"Your country is\\n\"+countryName,Toast.LENGTH_LONG).show();\r\n                Log.i(\"prueba\", countryName);\r\n                Log.i(\"prueba\", \"Latitud: \"+latitude+\"\\nLongitud: \"+longitude);\r\n                DBAccess database = new DBAccess(this);\r\n                database.open();\r\n                double distance = database.getDistance(countryName);\r\n                database.close();\r\n                Log.i(\"prueba\", String.valueOf(distance));\r\n                Toast.makeText(Main.this, \"Security distance: \"+distance, Toast.LENGTH_LONG).show();\r\n\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setProgressDialog() {\r\n\r\n        LayoutInflater inflater = LayoutInflater.from(Main.this);\r\n        View v = inflater.inflate(R.layout.alert_dialog, null, false);\r\n\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n        builder.setCancelable(false);\r\n        builder.setView(v);\r\n\r\n        alertDialog = builder.create();\r\n        alertDialog.show();\r\n        Window window = alertDialog.getWindow();\r\n        if (window != null) {\r\n            WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();\r\n            layoutParams.copyFrom(alertDialog.getWindow().getAttributes());\r\n            layoutParams.width = LinearLayout.LayoutParams.WRAP_CONTENT;\r\n            layoutParams.height = LinearLayout.LayoutParams.WRAP_CONTENT;\r\n            alertDialog.getWindow().setAttributes(layoutParams);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void receiveMessage(JSONObject data) {\r\n        try {\r\n            alertDialog.dismiss();\r\n            String capacity = data.getString(\"max_cap\");\r\n            showCapacity(capacity);\r\n        } catch (JSONException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void showCapacity(String capacity){\r\n        LayoutInflater inflater = LayoutInflater.from(this);\r\n        final View v = inflater.inflate(R.layout.show_capacity, null,false);\r\n\r\n        ((TextView)v.findViewById(R.id.capacidad)).setText(\"This room can accommodate \"+capacity+\" people\");\r\n\r\n        int width = LinearLayout.LayoutParams.WRAP_CONTENT;\r\n        int height = LinearLayout.LayoutParams.WRAP_CONTENT;\r\n\r\n        final PopupWindow popupWindow = new PopupWindow(v,width,height,true);\r\n        runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                popupWindow.showAtLocation(v, Gravity.CENTER, 0 ,0);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n        startBackgroundThread();\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n            requestUbicationPermission();\r\n            return;\r\n        }\r\n        if(!isLocationEnabled()){\r\n            showSettingsAlert();\r\n            return;\r\n        }\r\n\r\n        mBackgroundHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                getLocation();\r\n            }\r\n        });\r\n\r\n        if(mTextureView.isAvailable()){\r\n            openCamera(mTextureView.getWidth(), mTextureView.getHeight());  //If it's available, we open the camera\r\n        }else{\r\n            mTextureView.setSurfaceTextureListener(mSurfaceTextureListener); //If it's not available, we pass a listener in order to\r\n        }                                                                    //get notified when the camera is available\r\n    }\r\n\r\n    @Override\r\n    protected void onPause() {\r\n        stopBackgroundThread();\r\n        closeCamera();\r\n        super.onPause();\r\n\r\n    }\r\n\r\n    private void addOrientationListener()\r\n    {\r\n        OrientationEventListener listener=new OrientationEventListener(this, SensorManager.SENSOR_DELAY_NORMAL)\r\n        {\r\n            public void onOrientationChanged(int orientation) {\r\n                if (orientation >= 330 || orientation < 30) {\r\n                    mDisplayRotation = Surface.ROTATION_0;\r\n                } else if (orientation >= 60 && orientation < 120) {\r\n                    mDisplayRotation = Surface.ROTATION_270;\r\n                } else if (orientation >= 150 && orientation < 210) {\r\n                    mDisplayRotation = Surface.ROTATION_180;\r\n                } else if (orientation >= 240 && orientation < 300) {\r\n                    mDisplayRotation = Surface.ROTATION_90;\r\n                }\r\n            }\r\n        };\r\n\r\n        if(listener.canDetectOrientation())\r\n            listener.enable();\r\n    }\r\n\r\n\r\n\r\n    private void openCamera(int width, int height){\r\n        if(ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)\r\n        != PackageManager.PERMISSION_GRANTED){\r\n            requestCameraPermission();\r\n            return;\r\n        }\r\n        setUpCameraOutputs(width,height);\r\n        configureTransform(width,height);\r\n        CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);\r\n        try{\r\n            if(!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)){\r\n                throw new RuntimeException(\"Time out waiting to lock camera opening\");\r\n            }\r\n            manager.openCamera(mCameraId,mStateCallback,mBackgroundHandler);\r\n        }catch (CameraAccessException e){\r\n            e.printStackTrace();\r\n        }catch (InterruptedException e){\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera opening\", e);\r\n        }\r\n    }\r\n\r\n    private void closeCamera(){\r\n        try{\r\n            mCameraOpenCloseLock.acquire();\r\n            if(mCaptureSession != null){\r\n                mCaptureSession.close();\r\n                mCaptureSession=null;\r\n            }\r\n            if(mCameraDevice!=null){\r\n                mCameraDevice.close();\r\n                mCameraDevice=null;\r\n                Log.i(\"prueba\", \"Camera closed\");\r\n            }\r\n            if(mImageReader != null){\r\n                mImageReader.close();\r\n                mImageReader=null;\r\n            }\r\n        } catch (InterruptedException e){\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera closing\",e);\r\n        } finally {\r\n            mCameraOpenCloseLock.release();\r\n\r\n        }\r\n    }\r\n    \r\n    private void setUpCameraOutputs(int width, int height){\r\n        CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);\r\n        try{\r\n            for(String cameraId : manager.getCameraIdList()){\r\n                CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);\r\n                //We don't want to use front camera\r\n                Integer front = characteristics.get(CameraCharacteristics.LENS_FACING);\r\n                if(front != null && front == CameraCharacteristics.LENS_FACING_FRONT){\r\n                    continue;  //we skip the front camera loop, we only do the setup for the rear camera\r\n                }\r\n\r\n                StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\r\n                if(map == null){\r\n                    continue;\r\n                }\r\n                Size largest = Collections.max(Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)), //we get all the possible choices from an Image\r\n                        new CompareSizesByArea());\r\n                //mImageSize = largest;\r\n                mImageReader = ImageReader.newInstance(largest.getWidth(),largest.getHeight(),\r\n                        ImageFormat.JPEG,2);\r\n                mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);\r\n\r\n                mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\r\n                boolean swappedDimensions = false;\r\n                switch (mDisplayRotation){\r\n                    case Surface.ROTATION_0:\r\n                    case Surface.ROTATION_180:\r\n                        if(mSensorOrientation == 90 || mSensorOrientation == 270){\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    case Surface.ROTATION_90:\r\n                    case Surface.ROTATION_270:\r\n                        if(mSensorOrientation == 0 || mSensorOrientation == 180){\r\n                            swappedDimensions = true;\r\n                        }\r\n                }\r\n\r\n                Point displaySize = new Point();\r\n                getWindowManager().getDefaultDisplay().getSize(displaySize);\r\n                int rotatedPreviewWidth = width;\r\n                int rotatedPreviewHeight = height;\r\n                int maxPreviewWidth = displaySize.x;\r\n                int maxPreviewHeight = displaySize.y;\r\n\r\n                if(swappedDimensions){\r\n                    rotatedPreviewWidth = height;\r\n                    rotatedPreviewHeight = width;\r\n                    maxPreviewWidth = displaySize.y;\r\n                    maxPreviewHeight = displaySize.x;\r\n                }\r\n\r\n                if(maxPreviewWidth > MAX_PREVIEW_WIDTH){\r\n                    maxPreviewWidth = MAX_PREVIEW_WIDTH;\r\n                }\r\n                if(maxPreviewHeight > MAX_PREVIEW_HEIGHT){\r\n                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;\r\n                }\r\n\r\n                mPreviewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),  //we get all the possible choices of the preview\r\n                        rotatedPreviewWidth, rotatedPreviewHeight,maxPreviewWidth,maxPreviewHeight,largest);\r\n\r\n                if(mDisplayRotation == Surface.ROTATION_90 || mDisplayRotation == Surface.ROTATION_270){\r\n                    mTextureView.setAspectRatio(mPreviewSize.getWidth(), mPreviewSize.getHeight());\r\n                } else {\r\n                    mTextureView.setAspectRatio(mPreviewSize.getHeight(), mPreviewSize.getWidth());\r\n                }\r\n\r\n\r\n                mCameraId = cameraId;\r\n                return;\r\n            }\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (NullPointerException e){\r\n            Toast.makeText(Main.this,\"Camera2 API not supported on this device\", Toast.LENGTH_LONG).show();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private void createCameraPreviewSession(){\r\n        try{\r\n            SurfaceTexture texture = mTextureView.getSurfaceTexture();\r\n            assert texture != null;\r\n\r\n            texture.setDefaultBufferSize(mPreviewSize.getWidth(),mPreviewSize.getHeight());\r\n\r\n            Surface surface = new Surface(texture);\r\n\r\n            mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\r\n            mPreviewRequestBuilder.addTarget(surface);\r\n\r\n            mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),\r\n                    new CameraCaptureSession.StateCallback() {\r\n                        @Override\r\n                        public void onConfigured(@NonNull CameraCaptureSession session) {\r\n                            if(mCameraDevice == null){\r\n                                return;\r\n                            }\r\n\r\n                            mPreviewCaptureSession = session;\r\n                            //mCaptureSession = session;\r\n                            try{\r\n                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,\r\n                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n                                mPreviewRequest = mPreviewRequestBuilder.build();\r\n                                mPreviewCaptureSession.setRepeatingRequest(mPreviewRequest,null,mBackgroundHandler);\r\n                            } catch (CameraAccessException e){\r\n                                e.printStackTrace();\r\n                            }\r\n                        }\r\n\r\n                        @Override\r\n                        public void onConfigureFailed(@NonNull CameraCaptureSession session) {\r\n                        }\r\n                    }, null);\r\n        } catch (CameraAccessException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void startStillCaptureRequest(){\r\n        try {\r\n            //mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);\r\n            //mPreviewRequestBuilder.addTarget(mImageReader.getSurface());\r\n            final CaptureRequest.Builder captureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);\r\n            captureBuilder.addTarget(mImageReader.getSurface());\r\n            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n            //captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(mDisplayRotation));\r\n            CameraCaptureSession.CaptureCallback stillCaptureCallback = new\r\n                    CameraCaptureSession.CaptureCallback() {\r\n                        @Override\r\n                        public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) {\r\n                            super.onCaptureStarted(session, request, timestamp, frameNumber);\r\n                            /*try {\r\n                                createImageFileName();\r\n                            } catch (IOException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n\r\n                             */\r\n\r\n\r\n                        }\r\n                    };\r\n\r\n            mPreviewCaptureSession.capture(captureBuilder.build(),stillCaptureCallback, null);\r\n            mPreviewCaptureSession.capture(mPreviewRequestBuilder.build(),stillCaptureCallback, null);  //Handler null because stillCaptureCallback already is executed\r\n        } catch (CameraAccessException e) {                                                                     //from the background thread\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n/*\r\n    private int getOrientation(int rotation){\r\n        return (mSensorOrientation+ORIENTATIONS.get(rotation)+270)%360;\r\n    }\r\n\r\n */\r\n\r\n\r\n\r\n\r\n    private void lockFocus(){\r\n\r\n        /*if(ContextCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE)\r\n            != PackageManager.PERMISSION_GRANTED){\r\n            requestStoragePermission();\r\n            return;\r\n        }\r\n\r\n         */\r\n        mCaptureState = STATE_WAIT_LOCK;\r\n        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_START);\r\n        try {\r\n            mPreviewCaptureSession.capture(mPreviewRequestBuilder.build(),mPreviewCaptureCallback,mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void requestCameraPermission(){\r\n        if(ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.CAMERA)){\r\n            new AlertDialog.Builder(Main.this).setMessage(\"R string request permission\")\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            ActivityCompat.requestPermissions(Main.this,\r\n                                    new String[]{Manifest.permission.CAMERA},REQUEST_CAMERA_PERMISSION);\r\n                        }\r\n                    }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\r\n                @Override\r\n                public void onClick(DialogInterface dialog, int which) {\r\n                    finish();\r\n                }\r\n            }).create();\r\n        } else{\r\n            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA},\r\n                    REQUEST_CAMERA_PERMISSION);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        if(requestCode == REQUEST_CAMERA_PERMISSION){\r\n            if(grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED){\r\n                Toast.makeText(Main.this, \"ERROR: Camera permissions not granted\",\r\n                        Toast.LENGTH_LONG).show();\r\n            }\r\n        }else{\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        }\r\n\r\n        if(requestCode == REQUEST_GPS_LOCATION){\r\n            if(grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED){\r\n                Toast.makeText(Main.this, \"ERROR: Ubication permissions not granted\",\r\n                        Toast.LENGTH_LONG).show();\r\n            }\r\n        }else{\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        }\r\n\r\n        /*if(requestCode == REQUEST_STORAGE_PERMISSION){\r\n            if(grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED){\r\n                Toast.makeText(Main.this, \"ERROR: Storage writing permissions not granted\",\r\n                        Toast.LENGTH_LONG).show();\r\n            }\r\n        }else{\r\n            super.onRequestPermissionsResult(requestCode,permissions,grantResults);\r\n        }\r\n\r\n         */\r\n    }\r\n\r\n    private void startBackgroundThread(){\r\n        mBackgroundThread = new HandlerThread(\"Camera Background\");\r\n        mBackgroundThread.start();\r\n        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());\r\n    }\r\n\r\n    private void stopBackgroundThread(){\r\n        mBackgroundThread.quitSafely();\r\n        try{\r\n            mBackgroundThread.join();\r\n            mBackgroundThread=null;\r\n            mBackgroundHandler=null;\r\n        }catch (InterruptedException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static Size chooseOptimalSize(Size[] choices, int textureViewWidth, int textureViewHeight,\r\n                                          int maxWidth, int maxHeight, Size aspectRatio){\r\n        List<Size> bigEnough = new ArrayList<>();\r\n        List<Size> notBigEnough = new ArrayList<>();\r\n        int w = aspectRatio.getWidth();\r\n        int h = aspectRatio.getHeight();\r\n        for(Size option : choices){\r\n            if(option.getWidth() <= maxWidth && option.getHeight() <= maxHeight &&\r\n                option.getHeight() == option.getWidth()*h/w){\r\n                if(option.getWidth() >= textureViewWidth && option.getHeight() >= textureViewHeight){\r\n                    bigEnough.add(option);\r\n                }else {\r\n                    notBigEnough.add(option);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(bigEnough.size() > 0){\r\n            return Collections.min(bigEnough, new CompareSizesByArea());\r\n        }else if(notBigEnough.size() > 0){\r\n            return Collections.max(notBigEnough, new CompareSizesByArea());\r\n        } else {\r\n            Log.e(\"Camera2\", \"Couldn't find any suitable preview size\");\r\n            return choices[0];\r\n        }\r\n    }\r\n\r\n    private void configureTransform(int viewWidth, int viewHeight){\r\n        if (mTextureView == null || mPreviewSize == null){\r\n            return;\r\n        }\r\n        //int rotation = getWindowManager().getDefaultDisplay().getRotation();\r\n        int rotation = mDisplayRotation;\r\n        Matrix matrix = new Matrix();\r\n        RectF viewRect = new RectF(0,0, viewWidth, viewHeight);\r\n        RectF bufferRect = new RectF(0,0, mPreviewSize.getHeight(),mPreviewSize.getWidth());\r\n        float centerX = viewRect.centerX();\r\n        float centerY = viewRect.centerY();\r\n        if(Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation){\r\n            bufferRect.offset(centerX - bufferRect.centerX(), centerY-bufferRect.centerY());\r\n            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\r\n            float scale = Math.max((float) viewHeight/mPreviewSize.getHeight(), (float) viewWidth /mPreviewSize.getWidth());\r\n            matrix.postScale(scale,scale, centerX, centerY);\r\n            matrix.postRotate(90*(rotation-2), centerX,centerY);\r\n        } else if(Surface.ROTATION_180 == rotation){\r\n            matrix.postRotate(180, centerX,centerY);\r\n        }\r\n        mTextureView.setTransform(matrix);\r\n    }\r\n\r\n    static class CompareSizesByArea implements Comparator<Size> {\r\n\r\n        @Override\r\n        public int compare(Size lhs, Size rhs) {\r\n            return Long.signum((long) lhs.getWidth()*lhs.getHeight()-\r\n                    (long) rhs.getWidth()*rhs.getHeight());\r\n        }\r\n    }\r\n\r\n    private void requestUbicationPermission(){\r\n        if(ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.ACCESS_FINE_LOCATION)){\r\n            new AlertDialog.Builder(Main.this).setMessage(\"R string request permission\")\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            ActivityCompat.requestPermissions(Main.this,\r\n                                    new String[]{Manifest.permission.ACCESS_FINE_LOCATION},REQUEST_GPS_LOCATION);\r\n                        }\r\n                    }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\r\n                @Override\r\n                public void onClick(DialogInterface dialog, int which) {\r\n                    finish();\r\n                }\r\n            }).create();\r\n        } else{\r\n            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION},\r\n                    REQUEST_GPS_LOCATION);\r\n        }\r\n    }\r\n\r\n    /*\r\n    private void createImageFolder(){\r\n        File imageFile = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\r\n        mImageFolder = new File(imageFile, \"CovidSafeSpaces\");\r\n        if(!mImageFolder.exists()){\r\n            mImageFolder.mkdirs();\r\n        }\r\n    }\r\n\r\n     */\r\n\r\n    /*\r\n    private File createImageFileName() throws IOException {\r\n        String timestamp = new SimpleDateFormat(\"yyyyMMdd HHmmss\").format(new Date());\r\n        String prepend = \"IMAGE_\" + timestamp + \"_\";\r\n        File imageFile = new File(mImageFolder, prepend+\".jpeg\");\r\n        mImageFileName = imageFile.getAbsolutePath();\r\n        return imageFile;\r\n    }\r\n\r\n     */\r\n\r\n    private String createFileName(){\r\n        return new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\r\n    }\r\n\r\n\r\n    /*\r\n    private void requestStoragePermission(){\r\n        if(ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.WRITE_EXTERNAL_STORAGE)){\r\n            new AlertDialog.Builder(Main.this).setMessage(\"R string request permission\")\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            ActivityCompat.requestPermissions(Main.this,\r\n                                    new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_STORAGE_PERMISSION);\r\n                        }\r\n                    }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\r\n                @Override\r\n                public void onClick(DialogInterface dialog, int which) {\r\n                    finish();\r\n                }\r\n            }).create();\r\n        } else{\r\n            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\r\n                    REQUEST_STORAGE_PERMISSION);\r\n        }\r\n    }\r\n\r\n     */\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/covidsafespaces/Main.java	(revision 18c3b924d92e2a093285e0e703d8f9550e99715b)
+++ app/src/main/java/com/example/covidsafespaces/Main.java	(date 1603964563238)
@@ -183,7 +183,7 @@
             ByteBuffer byteBuffer = mImage.getPlanes()[0].getBuffer();
             byte[] bytes = new byte[byteBuffer.remaining()];
             byteBuffer.get(bytes);
-            new ServerConnection().postImage(bytes, createFileName(), mDisplayRotation);
+            new ServerConnection().postImage(bytes, createFileName(), mDisplayRotation, Main.this);
             mImage.close();
             /*FileOutputStream fileOutputStream = null;
             try {
@@ -379,6 +379,7 @@
                 Log.i("prueba", String.valueOf(distance));
                 Toast.makeText(Main.this, "Security distance: "+distance, Toast.LENGTH_LONG).show();
 
+
             }
         } catch (IOException e) {
             e.printStackTrace();
@@ -409,12 +410,27 @@
     @Override
     public void receiveMessage(JSONObject data) {
         try {
-            alertDialog.dismiss();
-            String capacity = data.getString("max_cap");
-            showCapacity(capacity);
+            String function = data.getString("function");
+            switch(function){
+                case "post":
+                    final String percentage = data.getString("Window percentage");
+                    runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            Toast.makeText(Main.this, "Window percentage: "+ percentage, Toast.LENGTH_LONG).show();
+                        }
+                    });
+                    break;
+                case "get":
+                    alertDialog.dismiss();
+                    String capacity = data.getString("max_cap");
+                    showCapacity(capacity);
+                    break;
+            }
         } catch (JSONException e) {
             e.printStackTrace();
         }
+
     }
 
     public void showCapacity(String capacity){
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"com.example.covidsafespaces\">\r\n\r\n    <uses-permission android:name=\"android.permission.CAMERA\" />\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />\r\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\r\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:requestLegacyExternalStorage=\"true\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/AppTheme\"\r\n        android:usesCleartextTraffic=\"false\"\r\n        android:networkSecurityConfig=\"@xml/network_security_config\">\r\n        <activity android:name=\".Register\"></activity>\r\n        <activity android:name=\".Main\"></activity>\r\n\r\n        <activity\r\n            android:name=\".Login\"\r\n            android:screenOrientation=\"portrait\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n    </application>\r\n\r\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(revision 18c3b924d92e2a093285e0e703d8f9550e99715b)
+++ app/src/main/AndroidManifest.xml	(date 1603965396863)
@@ -18,7 +18,7 @@
         android:usesCleartextTraffic="false"
         android:networkSecurityConfig="@xml/network_security_config">
         <activity android:name=".Register"></activity>
-        <activity android:name=".Main"></activity>
+        <activity android:name=".Main"></activity>-->
 
         <activity
             android:name=".Login"
